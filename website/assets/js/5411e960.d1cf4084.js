"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2342],{5845:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"multiarch-patching","title":"Multi-Arch Patching","description":"Copa also supports patching multi-architecture container images, streamlining the process of securing applications deployed across diverse hardware platforms. This guide explains how Copa handles multi-arch images and how you can use this feature.","source":"@site/docs/multiarch-patching.md","sourceDirName":".","slug":"/multiarch-patching","permalink":"/copacetic/website/next/multiarch-patching","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Multi-Arch Patching"},"sidebar":"sidebar","previous":{"title":"Scanner Plugins","permalink":"/copacetic/website/next/scanner-plugins"},"next":{"title":"Contributing","permalink":"/copacetic/website/next/contributing"}}');var r=n(4848),s=n(8453);const a={title:"Multi-Arch Patching"},c="Multi-Arch Patching",o={},h=[{value:"Usage",id:"usage",level:2},{value:"Example:",id:"example",level:3},{value:"Things to Keep in Mind",id:"things-to-keep-in-mind",level:3},{value:"Emulation and QEMU for Cross-Platform Patching \u2699\ufe0f",id:"emulation-and-qemu-for-cross-platform-patching-\ufe0f",level:2},{value:"Why Emulation is Needed:",id:"why-emulation-is-needed",level:3},{value:"Setting up QEMU:",id:"setting-up-qemu",level:3}];function l(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"multi-arch-patching",children:"Multi-Arch Patching"})}),"\n",(0,r.jsx)(i.p,{children:"Copa also supports patching multi-architecture container images, streamlining the process of securing applications deployed across diverse hardware platforms. This guide explains how Copa handles multi-arch images and how you can use this feature."}),"\n",(0,r.jsx)(i.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(i.p,{children:["To patch a multi-architecture image, you can use the ",(0,r.jsx)(i.code,{children:"copa patch"})," command with the ",(0,r.jsx)(i.code,{children:"--report-directory"})," flag (which tells Copa this will be a multi-arch patch) along with flags to specify your image, and desired output tag."]}),"\n",(0,r.jsx)(i.p,{children:"Basic Command Structure:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"copa patch \\\n  --image <your-multi-arch-image> \\\n  --report-directory <path-to-your-reports-directory> \\\n  --tag <desired-patched-image-tag> \\\n  [--push] \\\n  [--platform-specific-errors <fail|warn|skip>] \\\n"})}),"\n",(0,r.jsx)(i.p,{children:"Key Flags for Multi-Arch Patching:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--report-directory <directory_path>"}),": Specifies the directory containing platform-specific vulnerability reports."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--tag <final_tag>"})," (optional): The tag for the final, reassembled multi-arch manifest (e.g., ",(0,r.jsx)(i.code,{children:"1.0-patched"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--push"})," (optional): If included, Copa pushes the final multi-arch manifest to the registry."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--platform-specific-errors <fail|warn|skip>"})," (optional, default: ",(0,r.jsx)(i.code,{children:"skip"}),"): Determines how Copa handles errors encountered while patching an individual platform's sub-image."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"example",children:"Example:"}),"\n",(0,r.jsxs)(i.p,{children:["To patch a multi-arch image ",(0,r.jsx)(i.code,{children:"myregistry.io/app:1.2"})," using reports from the ",(0,r.jsx)(i.code,{children:"./scan_results"})," directory, tag the patched image as ",(0,r.jsx)(i.code,{children:"myregistry.io/app:1.2-patched"}),", and push it to the registry:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"copa patch \\\n  --image myregistry.io/app:1.2 \\\n  --report-directory ./scan_results \\\n  --tag 1.2-patched \\\n  --push\n"})}),"\n",(0,r.jsxs)(i.p,{children:["When patching ",(0,r.jsx)(i.code,{children:"myregistry.io/app:1.2"}),", Copa first determines the image\u2019s supported architectures, then walks the report directory and patches only those scan reports whose architectures match."]}),"\n",(0,r.jsx)(i.h3,{id:"things-to-keep-in-mind",children:"Things to Keep in Mind"}),"\n",(0,r.jsxs)(i.p,{children:["If you don't include the ",(0,r.jsx)(i.code,{children:"--report-directory"})," flag, Copa will not perform multi-arch patching and will instead only patch the image for the architecture of the host machine."]}),"\n",(0,r.jsxs)(i.p,{children:["If ",(0,r.jsx)(i.code,{children:"--push"})," is not specified, the individual patched images will be saved locally, and you can push them to your registry later using ",(0,r.jsx)(i.code,{children:"docker push"})," and then ",(0,r.jsx)(i.code,{children:"docker manifest create/push"})," to create the multi-arch manifest."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"emulation-and-qemu-for-cross-platform-patching-\ufe0f",children:"Emulation and QEMU for Cross-Platform Patching \u2699\ufe0f"}),"\n",(0,r.jsxs)(i.p,{children:["When patching an image for an architecture different from your host machine's architecture (e.g., patching an ",(0,r.jsx)(i.code,{children:"arm64"})," image on an ",(0,r.jsx)(i.code,{children:"amd64"})," machine), Copa relies on ",(0,r.jsx)(i.strong,{children:"emulation"}),". This is often necessary for multi-arch image patching, as you might not have native hardware for every architecture you intend to patch."]}),"\n",(0,r.jsxs)(i.p,{children:["Copa leverages ",(0,r.jsx)(i.strong,{children:"BuildKit"}),", which in turn can use ",(0,r.jsx)(i.strong,{children:"QEMU"})," for emulation. QEMU is a generic and open-source machine emulator and virtualizer. When BuildKit detects that it needs to execute binaries for a foreign architecture, it can use QEMU user-mode emulation to run those commands."]}),"\n",(0,r.jsx)(i.h3,{id:"why-emulation-is-needed",children:"Why Emulation is Needed:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Running Package Managers:"})," To apply patches, Copa needs to execute the package manager (like ",(0,r.jsx)(i.code,{children:"apk"}),", ",(0,r.jsx)(i.code,{children:"apt"}),", ",(0,r.jsx)(i.code,{children:"yum"}),") ",(0,r.jsx)(i.em,{children:"inside"})," the environment of the target image's architecture. If you're on an ",(0,r.jsx)(i.code,{children:"amd64"})," host trying to patch an ",(0,r.jsx)(i.code,{children:"arm64"})," image, the ",(0,r.jsx)(i.code,{children:"arm64"})," package manager won't run natively. QEMU bridges this gap."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Ensuring Correctness:"})," Emulation helps ensure that the patches are applied in an environment that closely mirrors the target architecture, reducing the chances of incompatibilities."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"setting-up-qemu",children:"Setting up QEMU:"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Docker Desktop (macOS and Windows) comes pre-configured with QEMU emulation support and requires no additional setup."})}),"\n",(0,r.jsxs)(i.p,{children:["For Linux hosts or when using BuildKit outside of Docker Desktop, your host system  (where the ",(0,r.jsx)(i.code,{children:"copa"})," command and BuildKit daemon are running) needs to have QEMU static binaries registered with the kernel's ",(0,r.jsx)(i.code,{children:"binfmt_misc"})," handler. This allows the kernel to automatically invoke QEMU when it encounters a binary for a foreign architecture."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Installation Steps (Linux/Non-Docker Desktop environments):"})}),"\n",(0,r.jsxs)(i.p,{children:["One way to set this up, especially in Dockerized environments or on Linux hosts, is to use the ",(0,r.jsx)(i.code,{children:"multiarch/qemu-user-static"})," image:"]}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsxs)(i.strong,{children:["Ensure your kernel supports ",(0,r.jsx)(i.code,{children:"binfmt_misc"}),":"]})," Most modern Linux kernels do."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Register QEMU handlers:"})," You can do this by running the ",(0,r.jsx)(i.code,{children:"multiarch/qemu-user-static"})," Docker image with privileged mode:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"docker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n"})}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>c});var t=n(6540);const r={},s=t.createContext(r);function a(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);